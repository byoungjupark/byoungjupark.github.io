---
title : "TIL39. Authentication(인증)의 여러 방법들"
excerpt : "서버 기반의 session과 cookie, 토큰 기반의 jwt"
---

장고 rest framework의 default 인증 방식은 서버 기반의 session 인증방법이다. 
프로젝트를 할 때에는 jwt를 사용한 토큰 기반의 인증방법을 사용했는데, 인증 방법는 여러가지가 있다는 것을 알았다.
이번 시간에는 여러 인증 방법에 대해 알아보고 개념을 정리해보고자 한다.
<br>

우선 HTTP는 stateless라는 특성을 지녀 각 통신의 상태가 저장되지 않는다. 
따라서 매 요청마다 사용자의 인증과 인가 작업을 거쳐야 한다. 
예를 들어, 로그인한 사용자가 이후 작업을 요청할 때 stateless 특성때문에 사용자가 로그인했다 라는 정보를 서버는 모른다. 
따라서 로그인 후에 세션이나 토큰과 같은 통행증을 부여하여 매 요청마다 통행증과 함께 요청을 할 수 있다. 
이러한 통행증에는 세션, 토큰, OAuth 와 같은 종류들이 있고 각각의 장단점이 있다.

# 1. 서버 기반 인증 (Session과 Cookie)
사용자의 정보를 서버에 저장하는 방식으로 session(세션)이라는 저장소를 사용한다.
아래와 같은 순서대로 동작한다.

<img width="538" alt="session" src="https://user-images.githubusercontent.com/63541271/140609401-da747e72-320c-4784-8748-5d5205cf308f.png">

- 사용자가 로그인을 한다.
- 데이터베이스에 있는 유효한 사용자인지 체크하고, 데이터가 맞을 때 세션을 생성하여 세션 저장소에 저장한다.
- 클라이언트에게 세션 id를 전송한다.
- 세션id는 클라이언트측 쿠키에 저장되어 사용자의 요청에 사용될 것이다.
- 요청 시 쿠키에 담긴 세션 정보와 세션저장소의 세션이 일치하는지 검증한다.
- 세션 검증을 마치면 관련 사용자 정보를 획득하여, 서버에서 로직을 처리한다.
- 요청한 데이터를 전송한다.

사용자가 로그아웃을 하면 클라이언트와 서버 모두에서 세션id가 삭제된다.
로그인을 새로 하면 새로운 세션id를 생성하게 된다.
안정성면에서는 토큰보다 세션이 더 안전하다. 
토큰은 xss attack과 같은 공격에 노출될 가능성이 더 크다.
세션을 사용할 때 주고받는 세션id의 크기는 작다. 
토큰도 같은 데이터를 담고 있어도 세션에 비해 크기가 크다.
<br>

하지만 확장성을 생각했을 때에는 토큰 방식이 좀 더 좋다.
세션은 서버에 저장이 되기 때문에 접속자가 많아지면 서버의 과부하가 발생할 수 있다.
과부하를 덜어주기 위해 여러 서버를 두고 서비스 운영을 하기도 한다.(로드밸런싱)
이것의 또다른 의미는 세션이 저장되는 서버도 분산될 수 있다는 점이다.
사용자 id가 저장된 서버가 여러대가 될 수 있고, 사용자의 연속적인 서비스 이용이 끊길 수 있다.
<br>

이러한 세션의 단점을 해결하기 위해 sticky session, session clustering이라는 방법도 나왔다. 
하지만 이 해결방안을 선택하는 데 드는 처리비용도 있을 것이고, 애초에 이러한 위험이 없는 토큰을 사용하는 것이 더 좋을 수 있다.

# 2. 토큰 기반 인증 (jwt)
토큰 기반 방식 중 jwt (JSON Web Token) 기반의 인증 방식에 대해 알아보자.
사용자 검증을 마친뒤 서버에서 토큰을 생성하여 클라이언트에 전송한다.
이후 토큰은 클라이언트 측 로컬스토리지에 저장되어 매 요청마다 HTTP 헤더에 담겨 보내진다.
서버는 토큰을 검증 후 사용자 정보를 획득하여 요청한 데이터를 응답한다.
토큰 기반은 인증방식은 확장성면에서 용이하다.

<img width="548" alt="token" src="https://user-images.githubusercontent.com/63541271/140609406-50fcc701-5ef8-4194-9aa5-0401ad5b735d.png">

세션인증방식은 세션을 삭제하면 그만이지만, 토큰은 클라이언트 측에 저장되기 때문에 노출될 위험이 더 크다. 
토큰을 탈취하여 악의적인 사용이 가능하다.

> **XSS attack (Cross Site Scripting)**<br>
해커가 악의적 의도의 js코드를 웹브라우저에서 실행시키는 것인데, 이 때 사용자의 토큰을 탈취당할 수 있다. 
웹스토리지(로컬스토리지와 세션스토리지)는 자바스크립트로 접근하는게 쉽기 때문에 XSS 공격에 취약하다.

> **CSRF (Cross Site Request Forgery)**<br>
XSS를 통해 서버에 변조된 request를 보내 악의적인 동작을 수행하는 공격을 말한다. 
사용자 몰래 계정 탈퇴, 회원정보 변경, 게시물이나 댓글 작성 등

## Access Token + Refresh Token
지금까지 프로젝트에 사용한 jwt 인증방식은 access token을 발급하여 사용한 것이었다.
우선 토큰은 한번 발급되면 유효기간이 완료될 때까지 계속 사용하게 되는데, 해커에게 정보가 털리더라도 대처할 방법이 없다. 
유효기간 전까지 삭제가 불가능하기 때문이다.
이 때 refresh token을 추가적으로 발급하여 사용한다면 보안성을 높일 수 있다.
access token의 유효기간을 짧게 설정하여 토큰 탈취시 빠르게 무효화를 시킬 수 있다. 

<img width="526" alt="refresh_token" src="https://user-images.githubusercontent.com/63541271/140609413-885127ed-e47c-4ed5-9e11-fe4ea719c3da.png">

- 로그인 및 사용자 검증 완료
- access token과 refresh token을 발급하여 전송한다.
- 이후 요청에서는 access token으로만 요청한다.
- access token 유효기간 만료 시, 서버는 권한 없음을 응답한다.
- 클라이언트는 refresh token과 access token을 헤더에 넣어, access token 발급 요청을 보낸다.
- 서버는 데이터터베이스의 refresh token과 클라이언트 측 refresh token을 비교한다. 
일치하며 유효기간이 지나지 않았다면 새로운 access token을 발급해준다.

위 흐름대로 보면 refresh token도 클라이언트 측(로컬스토리지나 쿠키 등)에서 저장하는 것으로 보인다.
access token처럼 똑같이 클라이언트 측에 저장을 하고 있다면, 토큰탈취의 위험은 여전히 존재한다.
유효기간이 긴 refresh token이 탈취되는 것이 더 큰 리스크일 것이다.
<br>

그럼 refresh token은 어디에 저장하는 것이 좋을까?
데이터베이스에 저장하는 것이다.
데이터베이스에 refresh token값을 저장하고 index값을 로컬스토리지나 쿠키에 저장하는 방법이다.
큰 의미없는 index값만 노출되므로 좀 더 안전하다. 
index값도 해쉬된 값을 생성하여 사용하면 보안에 더욱 유리할 것이다.
